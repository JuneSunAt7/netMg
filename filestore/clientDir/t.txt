Когда у вас есть два слайса байт или две строки, вам может понадобится получить ответ на два вопроса. Первый — равны ли эти два объекта? И второй — какой из объектов идёт раньше при сортировке?


Равенство

Функция Equal() отвечает на первый вопрос:


func Equal(a, b []byte) bool

Эта функция есть только в пакете bytes, так как строки можно сравнивать с помощью оператора ==.


Хотя проверка на равенство может показаться простой задачей, есть популярная ошибка в использовании strings.ToUpper() для проверки на равенство без учёта регистра:


if strings.ToUpper(a) == strings.ToUpper(b) {
       return true
}

Этот подход неправильный, он использует 2 аллокации для новых строк. Гораздо более правильный подход это использование EqualFold():


func EqualFold(s, t []byte) bool
func EqualFold(s, t string) bool

Слово Fold тут означает Unicode case-folding. Оно охватывает правила для верхнего и нижнего регистра не только для A-Z, но и для других языков, и умеет конвертировать φ в ϕ.


Сравнение

Чтобы узнать порядок для сортировке двух слайсов байт или строк, у нас есть функция Compare():


func Compare(a, b []byte) int
func Compare(a, b string) int

Эта функция возвращает -1, если a меньше b, 1, если a больше b и 0, если a и b равны. Эта функция присутствует в пакете strings исключительно для симметрии с bytes. Russ Cox даже призывает к тому, что "никто не должен использовать strings.Compare". Проще использовать встроенные операторы < и >.


"никто не должен использовать strings.Compare", Russ Cox

Обычно вам нужно сравнивать слайсы байт или строк при сортировке данных. Интерфейс sort.Interface нуждается в функции сравнения для метода Less(). Чтобы перевести тернарную форму возвращаемого значения Compare() в логическое значение для Less(), достаточно просто проверить на равенство с -1:


type ByteSlices [][]byte
func (p ByteSlices) Less(i, j int) bool {
        return bytes.Compare(p[i], p[j]) == -1
}

