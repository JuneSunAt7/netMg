### Клиент-серверный файловый сервис на базе протокола TCP
Клиент *client.go* шифрует свои  файлы  [алгоритмом AES с режимом CBC](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation) и помещает их на сервер *server.go*. Также, скачивает их с сервера и расшифровывает.

#### Порядок работы:
- [x] Пользователь запускает *client.go*. При успешном соединении клиента с сервером вводит свой логин/пароль для входа на сервер. Появляется строка приглашения **ftp>**.
- [x] Для копирования своего файла на сервер вводит `upload <имя своего файла>`, затем пароль (не меньше 5ти символов).
- [x] Происходит шифрование файла алгоритмом AES с режимом CBC, затем передача файла на сервер. Сервер сообщает новое имя файла в формате UUID.
- [x] Пользователь может просмотреть список файлов на сервере при помощи *ls*.
- [x] Пользователь вводит имя (на сервере все имена файлов в формате UUID) нужного ему файла `upload <имя файла на сервере>`, затем пароль, который использовался для шифрования.
- [x] Происходит передача файла с сервера на клиентскую часть, расшифровка и сохранение с серверным именем. 


#### Список команд:
- **upload <имя файла>** передача файла на сервер из папки `filestore/clientDir` в `filestore`
- **download <UUID имя файла>** передача файла с сервера клиенту с расшифровкой на стороне клиента
- **ls** список файлов на сервере
-  **close/exit** закрыть TCP-соединение с сервером


#### Config and run
Заполнить `credential.json` usernames/passwords.
В рабочей папке открыть два терминала,

1st terminal:
```bash
go run cmd/server.go
```
2nd terminal:
```bash
#Multiple clients can be attached 
go run cmd/client/client.go
```
*Make sure to allow traffic to the port 2121 specified on your VPC firewall.*

#### Code review:
Проект выполнен встроенным набором Golang 1.17.1 без сторонних библиотек, за исключением получения UUID при помощи [google/uuid](github.com/google/uuid).


Наиболее сложный алгоритм `client/getfile.go` передачи файла с сервера:
- Клиент посылает команду *download <UUID имя файла>* и ожидает ответ
- Сервер отправляет обратную команду содержащую размер файла и ожидает ответ
- Клиент обрабатывает размер файла, посылает команду *200 Start download!* и ожидает файл
- Сервер отправляет файл
- Клиент получает поток байтов заданного размера (файл), расшифровывает его и сохраняет на диск под серверным именем
- Клиент передает пользователю md5 hash полученного файла, чтобы его можно было сравнить с md5 hash исходного файла

Асинхронность достигается выделением каждого хендлера соединения `net.Conn` в отдельную *go routine*, что обеспечиает потоковую безопасность каждого соединения: у хендлеров нет общих переменных, одновременная запись клиентами одного файла с одинаковым  UUID практически недостижима.

Для серверной части приложения разработана система записи логов по сути объединяющая два log.New для вывода на экран и записи в файл. Логгер является конкурентно безопасным (*A Logger can be used simultaneously from multiple goroutines; it guarantees to serialize access to the Writer.*).

Обнаружилось, что для блочного шифрования файла его исходный разиер в байтах должен быть кратным 16. Поэтому при шифровании в `client/crypto.go` выполнено дописывание в конец исходного файла \x01 и затем нулей \x00, которые соответственно убираются после дешифровки.

Также, в примерах кода не был найден образец передачи данных потоком (возможно, такой возможности нет в самом алгоритме блочного шифрования), поэтому процесс шифрования/дешифрования занимает в памяти клиента более двух размеров файла. Предполагается, что на машине клиента выполняется немного таких процессов.

Создан тест `client/crypto_test.go` для проверки шифрования-дешифрования произвольных строк, а также сравнения времени выполнения (Benchmark) шифрования и дешифрования. По результатам тестов они приблизительно равны.

Выполнен скрипт  `win_client.sh` для компиляции клиентской части приложения под Windows (client.exe).

Добавлена возможность защищенного SFTP, `crypto/tls` соединения. Для него необходимы сертификаты "server.crt", "server.key" на серверной части. Запуск осуществляется добавлением флага -tls соответственно при запуске сервера и клиента.

Для улучшения работы консоли рассматривалось применение Go аналога *Readline library*.

Код проверен линтерами staticcheck, revivle.

Thanks for samples [bisakhmondal/FTP-Go](https://github.com/bisakhmondal/FTP-Go), [kdama/gopl](https://github.com/kdama/gopl/tree/master/ch08/ex02), [fclairamb/ftpserver](https://github.com/fclairamb/ftpserver).












